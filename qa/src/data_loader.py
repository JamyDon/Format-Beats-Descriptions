import os
import json
import random
from typing import List, Dict, Tuple, Union
import re


DATASET2CLASS = {}

def get_dataset(dataset_name: str, **config):
    if dataset_name not in DATASET2CLASS:
        raise NotImplementedError(f"Dataset {dataset_name} is not registered.")
    return DATASET2CLASS[dataset_name](**config)

def dataset_register(cls):
    DATASET2CLASS[cls.__name__.replace("Data", "").lower()] = cls
    return cls

class ReasoningData:
    def __init__(self, dataset_name, **config) -> None:
        self.dataset_name = dataset_name
        
        if config.get("instruction", None) is not None:
            self.instruction = config["instruction"]
        else:
            raise ValueError("Instruction is not provided.")
        
        if config.get("data_dir", None) is not None:
            self.data_dir = config["data_dir"]
        else:
            raise ValueError("Data directory is not provided.")
        
        if config.get("before_test_input", None) is not None:
            self.before_test_input = config["before_test_input"]
        else:
            self.before_test_input = "Consider the following statement or question."

        # self.instruction_postfix = "Provide reasoning for your determination first and then provide your answer."

    def load_data(self, **kwargs) -> Tuple[List[str], Tuple[List[str], List[str]]]:
        """
        Load the data from the given directory and return the `exemplars` and `(test_inputs, gold_answers)`.
        """
        is_cot = kwargs.get("is_cot", False)
        shot = kwargs.get("shot", 4)

        train_data_path, test_data_path = self._find_data_paths(self.data_dir)

        if train_data_path.endswith("json"):
            with open(train_data_path, "r") as f:
                train_data = json.load(f)
            with open(test_data_path, "r") as f:
                test_data = json.load(f)
        else:
            with open(train_data_path, "r") as f:
                train_data = [json.loads(line) for line in f]
            with open(test_data_path, "r") as f:
                test_data = [json.loads(line) for line in f]

        self.exemplars = self._construct_exemplars(train_data, is_cot=is_cot, shot=shot)

        # skip = kwargs.get("skip", 0)
        self.test_inputs = self._get_test_inputs(test_data, **kwargs)

        return self.exemplars, self.test_inputs

    def _construct_exemplars(self, data, is_cot, shot):
        raise NotImplementedError
    
    def _get_test_inputs(self, data):
        raise NotImplementedError
    
    def _find_data_paths(self, data_dir: str) -> Tuple[str, str]:
        """
        Return the paths to the train and test/dev data files in the given directory.
        The train data file is always placed first.
        """

        file_names = os.listdir(data_dir)
        all_data_paths = []
        for file_name in file_names:
            if not file_name.endswith((".json", ".jsonl")):
                continue
            if "dev" not in file_name and "train" not in file_name and "test" not in file_name:
                continue
            all_data_paths.append(os.path.join(data_dir, file_name))
        if len(all_data_paths) != 2:
            raise ValueError(f"Expected 2 data files in {data_dir}, but found {len(all_data_paths)}")
        
        # Place the train data first
        if "train" not in all_data_paths[0]:
            all_data_paths = all_data_paths[::-1]

        return all_data_paths[0], all_data_paths[1]
    
    def parse_output(self, output, **kwargs):
        """Parse the output generated by the model."""
        output = output.replace("\n", " ").strip()

        if "So the answer is" in output:
            return output.split("So the answer is")[-1].strip().replace(".", "").lower()
        elif "The answer is" in output:
            return output.split("The answer is")[-1].strip().replace(".", "").lower()
        elif "answer is" in output:
            return output.split("answer is")[-1].strip().replace(".", "").lower()
        elif "answer should be" in output:
            return output.split("answer should be")[-1].strip().replace(".", "").lower()
        elif "the statement is" in output.lower():
            return output.split("the statement is")[-1].strip().replace(".", "").lower()
        else:
            return output
        
    def evaluate_from_file(self, output_file, **kwargs):
        raise NotImplementedError
    
    def evaluate(self, preds, **kwargs):
        if not getattr(self, "test_inputs", None):
            self.load_data(**kwargs)

        gold_answers = self.test_inputs[1]
        correct = 0
        for pred, gold in zip(preds, gold_answers):
            if pred == gold:
                correct += 1
        
        return correct / len(preds)
    

@dataset_register
class CSQAData(ReasoningData):
    def __init__(
            self, 
            instruction: str="Read the question and choose the correct answer.", 
            before_test_input: str="Consider the following question.",
            data_dir: str="../data/commonsense/csqa",
            **kwargs
        ) -> None:
        super().__init__("csqa", instruction=instruction, before_test_input=before_test_input, data_dir=data_dir, **kwargs)

    def _construct_exemplars(self, data, is_cot, shot) -> List[str]:
        data: List[Dict] = data[:shot]

        exemplars = []
        for item in data:
            question: str = item["Q"]
            answer_choices: str = item["Answer Choices"]
            answer: str = item["A"]

            if not is_cot:
                answer = "The answer is " + answer.split("So the answer is ")[-1]
            exemplars.append(f"Q: {question}\nAnswer Choices:\n{answer_choices}\nA: {answer}")

        return exemplars

    def _get_test_inputs(self, data, **kwargs) -> Tuple[List[str], List[str]]:
        test_inputs = []
        gold_answers = []
        for item in data:
            question: str = item["question"]["stem"]
            Options: List[Dict] = item["question"]["choices"]
            answer: str = item["answerKey"]

            answer_choices = []
            for option in Options:
                op_label = option["label"].lower()
                op_text = option["text"]
                answer_choices.append(f"({op_label}) {op_text}")

            answer_choices = "\n".join(answer_choices)

            test_inputs.append(f"Q: {question}\nAnswer Choices:\n{answer_choices}\nA:")
            gold_answers.append(answer.lower())

        return test_inputs, gold_answers
    
    def evaluate_from_file(self, output_file, **kwargs):
        with open(output_file, "r") as f:
            outputs = f.readlines()
        
        preds = []
        for output in outputs:
            output = output.strip()

            pattern = r'\([a-eA-E]'

            match = re.search(pattern, output)

            if match:
                pred = match.group(0).replace("(", "").lower()
            else:
                pred = None

            preds.append(pred)

        return self.evaluate(preds, **kwargs)
    

@dataset_register
class StrategyQAData(ReasoningData):
    def __init__(
            self,
            instruction: str="Read the question and answer yes or no.",
            before_test_input: str="Consider the following question.",
            data_dir: str="../data/commonsense/strategyqa",
            **kwargs
        ) -> None:
        super().__init__("strategyqa", instruction=instruction, before_test_input=before_test_input, data_dir=data_dir, **kwargs)

    def _construct_exemplars(self, data, is_cot, shot) -> List[str]:
        data: List[Dict] = data["examples"][:shot]

        exemplars = []
        for item in data:
            question: str = item["input"]

            target: str = item["target"]
            if target.startswith("Yes"):
                answer = "yes"
                reasoning = target.replace("Yes. ", "", 1)
            else:
                answer = "no"
                reasoning = target.replace("No. ", "", 1)

            if not is_cot:
                answer = f"The answer is {answer}."
            else:
                answer = f"{reasoning} So the answer is {answer}."

            exemplars.append(f"Q: {question}\nA: {answer}")

        return exemplars

    def _get_test_inputs(self, data, **kwargs) -> Tuple[List[str], List[str]]:
        test_inputs = []
        gold_answers = []
        for item in data["examples"]:
            question: str = item["input"]

            test_inputs.append(f"Q: {question}\nA:")
            gold_answers.append(item["target"].split(".")[0].lower())

        return test_inputs, gold_answers
    
    def evaluate_from_file(self, output_file, **kwargs):
        with open(output_file, "r") as f:
            outputs = f.readlines()
        
        preds = []
        for output in outputs:
            output = output.lower().strip()

            if output.startswith(("yes", "Yes", "YES")):
                pred = "yes"
            elif output.startswith(("no", "No", "NO")):
                pred = "no"
            else:
                # match the word after the "answer is "
                pattern = r'answer is [a-z]+'
                match = re.search(pattern, output)

                if match:
                    pred = match.group(0).split("answer is ")[-1].lower()
                else:
                    pred = None

            preds.append(pred)

        return self.evaluate(preds, **kwargs)
    

@dataset_register
class AquaData(ReasoningData):
    def __init__(
            self,
            instruction: str="Read the question and choose the correct answer.",
            before_test_input: str="Consider the following question.",
            data_dir: str="../data/math/aqua",
            **kwargs
        ) -> None:
        super().__init__("aqua", instruction=instruction, before_test_input=before_test_input, data_dir=data_dir, **kwargs)

    def _construct_exemplars(self, data, is_cot, shot) -> List[str]:
        data: List[Dict] = data[:shot]

        exemplars = []
        for item in data:
            question: str = item["Q"]
            answer_choices: str = item["Answer Choices"]
            answer: str = item["A"]

            if not is_cot:
                answer = "The answer is" + answer.split("The answer is")[-1]
            exemplars.append(f"Q: {question}\nAnswer Choices:\n{answer_choices}\nA: {answer}")

        return exemplars

    def _get_test_inputs(self, data, **kwargs) -> Tuple[List[str], List[str]]:
        test_inputs = []
        gold_answers = []
        for item in data:
            question: str = item["question"]
            answer_choices: List[str] = [f"({option[:2]} {option[2:]}" for option in item["options"]]
            answer_choices = " ".join(answer_choices)
            answer = item["correct"].lower()

            test_inputs.append(f"Q: {question}\nAnswer Choices:\n{answer_choices}\nA:")
            gold_answers.append(answer)

        return test_inputs, gold_answers
    
    def evaluate_from_file(self, output_file, **kwargs):
        with open(output_file, "r") as f:
            outputs = f.readlines()
        
        preds = []
        for output in outputs:
            output = output.strip()

            pattern = r'\([a-eA-E]'

            match = re.search(pattern, output)

            if match:
                pred = match.group(0).replace("(", "").lower()
            else:
                pred = None

            preds.append(pred)

        return self.evaluate(preds, **kwargs)
            

@dataset_register
class GSM8KData(ReasoningData):
    def __init__(
            self,
            instruction: str="Read the question and give your answer.",
            before_test_input: str="Consider the following question.",
            data_dir: str="../data/math/gsm8k",
            **kwargs
        ) -> None:
        super().__init__("gsm8k", instruction=instruction, before_test_input=before_test_input, data_dir=data_dir, **kwargs)

    def _construct_exemplars(self, data, is_cot, shot) -> List[str]:
        filtered_data = [item for item in data if len(item["answer"].split("\n")) < 5]

        random_seed = 42
        random.seed(random_seed)
        data: List[Dict] = random.sample(filtered_data, shot)

        exemplars = []
        for item in data:
            question: str = item["question"]
            reasoning: List[str] = item["answer"].split("\n")[:-1]
            reasoning_str = ""
            for step, reason in enumerate(reasoning):
                if reason.endswith("."):
                    reasoning_str += f"{step+1}): {reason} "
                else:
                    reasoning_str += f"{step+1}): {reason}. "

            answer: str = "The answer is " + item["answer"].split("\n")[-1].replace("#### ", "") + "."

            if not is_cot:
                exemplars.append(f"Q: {question}\nA: {answer}")
            else:
                # answer = answer.replace("The answer is", "So the answer is")
                exemplars.append(f"Q: {question}\nReasoning: {reasoning_str}\nA: {answer}")

        return exemplars
    
    def parse_output(self, output, **kwargs) -> Union[str, Tuple[str, str]]:
        if "is_cot" in kwargs:
            is_cot = kwargs["is_cot"]
        if "gen_text" in kwargs:
            gen_text = kwargs["gen_text"]

        if not is_cot:
            return super().parse_output(output, **kwargs)
        else:
            if "A:" not in output:
                new_prompt = gen_text + "\nA:"
                return output, new_prompt
            else:
                output = output.replace("\n", " ")
                output = output.split("A:")[1].strip()
                return output
        
    
    def _get_test_inputs(self, data, **kwargs) -> Tuple[List[str], List[str]]:
        if "is_cot" in kwargs:
            is_cot = kwargs["is_cot"]
        else:
            is_cot = False

        test_inputs = []
        gold_answers = []
        for item in data:
            question: str = item["question"]
            answer = item["answer"].split("\n")[-1].replace("#### ", "").lower()

            if not is_cot:
                test_inputs.append(f"Q: {question}\nA:")
            else:
                test_inputs.append(f"Q: {question}")

            gold_answers.append(answer)

        return test_inputs, gold_answers
    
    def evaluate_from_file(self, output_file, **kwargs):
        with open(output_file, "r") as f:
            outputs = f.readlines()
        
        preds = []
        for output in outputs:
            output = output.strip()

            pattern = re.compile(r'(-?\$?\d+(?:,\d{3})*(?:\.\d+)?(?:[eE][-+]?\d+)?%?)')

            match = pattern.search(output)
            if match:
                numeric_value = match.group(1)
                # Remove any non-numeric characters ($, %, etc.)
                cleaned_value = re.sub(r'[^-\d.eE]', '', numeric_value)
                pred = cleaned_value
            else:
                pred = None

            preds.append(pred)

        return self.evaluate(preds, **kwargs)

    def evaluate(self, preds, **kwargs):
        if not getattr(self, "test_inputs", None):
            self.load_data(**kwargs)

        gold_answers = self.test_inputs[1]
        gold_answers = [re.sub(r'[^-\d.eE]', '', answer) for answer in gold_answers]

        correct = 0
        for pred, gold in zip(preds, gold_answers):
            if pred == gold:
                correct += 1
        
        return correct / len(preds)
    

@dataset_register
class DateData(ReasoningData):
    def __init__(
            self,
            instruction: str="Answer question or questions about date inference.",
            before_test_input: str="Consider the following question.",
            data_dir: str="../data/commonsense/date",
            **kwargs
        ) -> None:
        super().__init__("date", instruction=instruction, before_test_input=before_test_input, data_dir=data_dir, **kwargs)

    def _construct_exemplars(self, data, is_cot, shot) -> List[str]:
        data: List[Dict] = data["examples"][:shot]

        exemplars = []
        for item in data:
            question: str = item["input"]
            answer: str = [k for k, v in item["target_scores"].items() if v == 1][0]

            if not is_cot:
                answer = "The answer is " + answer + "."
            else:
                answer = item["A"]
            exemplars.append(f"Q: {question}\nA: {answer}")

        return exemplars

    def _get_test_inputs(self, data, **kwargs) -> Tuple[List[str], List[str]]:
        data: List[Dict] = data["examples"]

        test_inputs = []
        gold_answers = []
        for item in data:
            question: str = item["input"]
            answer: str = [k for k, v in item["target_scores"].items() if v == 1][0]

            test_inputs.append(f"Q: {question}\nA:")
            gold_answers.append(answer)

        return test_inputs, gold_answers
    
    def evaluate_from_file(self, output_file, **kwargs):
        with open(output_file, "r") as f:
            outputs = f.readlines()
        
        preds = []
        for output in outputs:
            output = output.strip()

            pattern = r'\b(0[1-9]|1[0-2])\/(0[1-9]|[12][0-9]|3[01])\/(\d\d\d\d)\b'

            matches = re.findall(pattern, output)
            
            pred = "/".join(matches[0]) if matches else "None"

            preds.append(pred)

        return self.evaluate(preds, **kwargs)
    

@dataset_register
class SportsData(ReasoningData):
    def __init__(
            self,
            instruction: str="Determine whether a statement is plausible or implausible.",
            before_test_input: str="Consider the following statement.",
            data_dir: str="../data/commonsense/sports",
            **kwargs
        ) -> None:
        super().__init__("sports", instruction=instruction, before_test_input=before_test_input, data_dir=data_dir, **kwargs)

    def _construct_exemplars(self, data, is_cot, shot) -> List[str]:
        data: List[Dict] = data["examples"][:shot]

        exemplars = []
        for item in data:
            statement: str = item["input"] + "."
            answer: str = [k for k, v in item["target_scores"].items() if v == 1][0]

            if not is_cot:
                answer = "The statement is " + answer + "."
            else:
                answer = item["A"]
            exemplars.append(f"Statement: {statement}\nA: {answer}")

        return exemplars

    def _get_test_inputs(self, data, **kwargs) -> Tuple[List[str], List[str]]:
        data: List[Dict] = data["examples"]

        test_inputs = []
        gold_answers = []
        for item in data:
            statement: str = item["input"] + "."
            answer: str = [k for k, v in item["target_scores"].items() if v == 1][0]

            test_inputs.append(f"Statement: {statement}\nA:")
            gold_answers.append(answer)

        return test_inputs, gold_answers
    
    def evaluate_from_file(self, output_file, **kwargs):
        with open(output_file, "r") as f:
            outputs = f.readlines()
        
        preds = []
        for output in outputs:
            output = output.strip()
            output = output.replace("'", "").replace('"', "").lower()

            if output.startswith(("plausible", "the statement is plausible")):
                pred = "plausible"
            elif output.startswith(("implausible", "the statement is implausible")):
                pred = "implausible"
            else:
                pred = None

            preds.append(pred)

        return self.evaluate(preds, **kwargs)


@dataset_register
class LogicalFallacyData(ReasoningData):
    def __init__(
            self,
            instruction: str="You are an AI. Read the input and give your answer.",
            before_test_input: str="Consider the following input.",
            data_dir: str="../data/logic/logical_fallacy_detection",
            **kwargs
        ) -> None:
        super().__init__("logical_fallacy", instruction=instruction, before_test_input=before_test_input, data_dir=data_dir, **kwargs)

    def _construct_exemplars(self, data, is_cot, shot) -> List[str]:
        data: List[Dict] = data["examples"][:shot]

        exemplars = []
        for item in data:
            question: str = item["input"]
            answer: str = [k for k, v in item["target_scores"].items() if v == 1][0]
            answer = answer.lower()

            if not is_cot:
                answer = "The answer is " + answer + "."
            else:
                answer = item["A"]
            exemplars.append(f"Input: {question}\nA: {answer}")

        return exemplars

    def _get_test_inputs(self, data, **kwargs) -> Tuple[List[str], List[str]]:
        data: List[Dict] = data["examples"]

        test_inputs = []
        gold_answers = []
        for item in data:
            question: str = item["input"]
            answer: str = [k for k, v in item["target_scores"].items() if v == 1][0]
            answer = answer.lower()

            test_inputs.append(f"Input: {question}\nA:")
            gold_answers.append(answer)

        return test_inputs, gold_answers
    
    def evaluate_from_file(self, output_file, **kwargs):
        with open(output_file, "r") as f:
            outputs = f.readlines()
        
        preds = []
        for output in outputs:
            output = output.strip()
            output = output.replace("'", "").replace('"', "").lower()

            if output.startswith("valid"):
                pred = "valid"
            elif output.startswith("invalid"):
                pred = "invalid"
            elif output.replace(".", "").endswith("valid"):
                pred = "valid"
            elif output.replace(".", "").endswith("invalid"):
                pred = "invalid"
            else:
                pred = None

            preds.append(pred)

        return self.evaluate(preds, **kwargs)
    

@dataset_register
class ThreeObjectsData(ReasoningData):
    def __init__(
            self,
            instruction: str="Read the statement and choose the correct answer.",
            before_test_input: str="Consider the following statement.",
            data_dir: str="../data/logic/three_objects",
            **kwargs
        ) -> None:
        super().__init__("three_objects", instruction=instruction, before_test_input=before_test_input, data_dir=data_dir, **kwargs)

    def _construct_exemplars(self, data, is_cot, shot) -> List[str]:
        data: List[Dict] = data["examples"][:shot]

        exemplars = []
        for item in data:
            statement: str = item["input"]
            answer_choices_list: List[str] = item["target_scores"].keys()

            answer_choices = ""
            answer = ""
            for answer_key, choice in zip("abc", answer_choices_list):
                if item["target_scores"][choice] == 1:
                    answer = f"({answer_key})"
                answer_choices += f"({answer_key}) {choice}\n"

            if not is_cot:
                answer = "The answer is " + answer + "."
            else:
                reasoning = item["A"]
                answer = f"{reasoning} So the answer is {answer}."

            exemplars.append(f"Statement: {statement}\nAnswer Choices:\n{answer_choices}A: {answer}")

        return exemplars
    
    def _get_test_inputs(self, data, **kwargs) -> Tuple[List[str], List[str]]:
        data: List[Dict] = data["examples"]

        test_inputs = []
        gold_answers = []
        for item in data:
            statement: str = item["input"]
            answer_choices_list: List[str] = item["target_scores"].keys()

            answer_choices = ""
            for answer_key, choice in zip("abc", answer_choices_list):
                if item["target_scores"][choice] == 1:
                    answer = answer_key  # without the parentheses
                answer_choices += f"({answer_key}) {choice}\n"

            test_inputs.append(f"Statement: {statement}\nAnswer Choices:\n{answer_choices}A:")
            gold_answers.append(answer)

        return test_inputs, gold_answers
    
    def evaluate_from_file(self, output_file, **kwargs):
        with open(output_file, "r") as f:
            outputs = f.readlines()
        
        preds = []
        for output in outputs:
            output = output.strip()

            pattern = r'\([a-cA-C]'

            match = re.search(pattern, output)

            if match:
                pred = match.group(0).replace("(", "").lower()
            else:
                pred = None

            preds.append(pred)

        return self.evaluate(preds, **kwargs)
    

@dataset_register
class KnownUnknownsData(ReasoningData):
    def __init__(
            self,
            instruction: str="Read the question and choose the proper answer.",
            before_test_input: str="Consider the following question.",
            data_dir: str="../data/hallucination/known_unknowns",
            **kwargs
        ) -> None:
        super().__init__("known_unknowns", instruction=instruction, before_test_input=before_test_input, data_dir=data_dir, **kwargs)

    def _construct_exemplars(self, data, is_cot, shot) -> List[str]:
        data: List[Dict] = data["examples"][:shot]

        exemplars = []
        for item in data:
            statement: str = item["input"]
            answer_choices_list: List[str] = item["target_scores"].keys()

            answer_choices = ""
            answer = ""
            for answer_key, choice in zip("ab", answer_choices_list):
                if item["target_scores"][choice] == 1:
                    answer = f"({answer_key})"
                answer_choices += f"({answer_key}) {choice}\n"

            if not is_cot:
                answer = "The answer should be " + answer + "."
            else:
                reasoning = item["A"]
                prefix = reasoning.split("So the answer is ")[0]
                answer = f"{prefix}So the answer should be {answer}."

            exemplars.append(f"Statement: {statement}\nAnswer Choices:\n{answer_choices}A: {answer}")

        return exemplars
    
    def _get_test_inputs(self, data, **kwargs) -> Tuple[List[str], List[str]]:
        data: List[Dict] = data["examples"]
        
        test_inputs = []
        gold_answers = []
        for item in data:
            statement: str = item["input"]
            answer_choices_list: List[str] = item["target_scores"].keys()

            answer_choices = ""
            for answer_key, choice in zip("ab", answer_choices_list):
                if item["target_scores"][choice] == 1:
                    answer = answer_key  # without the parentheses
                answer_choices += f"({answer_key}) {choice}\n"

            test_inputs.append(f"Statement: {statement}\nAnswer Choices:\n{answer_choices}A:")
            gold_answers.append(answer)

        return test_inputs, gold_answers
    
    def evaluate_from_file(self, output_file, **kwargs):
        with open(output_file, "r") as f:
            outputs = f.readlines()
        
        preds = []
        for output in outputs:
            output = output.strip()

            pattern = r'\([a-bA-B]'

            match = re.search(pattern, output)

            if match:
                pred = match.group(0).replace("(", "").lower()
            else:
                pred = None

            preds.append(pred)

        return self.evaluate(preds, **kwargs)
    